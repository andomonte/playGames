{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport NextAuth from 'next-auth';\nimport Providers from 'next-auth/providers';\nimport ldap from 'ldapjs'; // const ldap = require('ldapjs');\n\nexport default NextAuth({\n  providers: [Providers.Credentials({\n    name: 'LDAP',\n    credentials: {\n      username: {\n        label: 'DN',\n        type: 'text',\n        placeholder: ''\n      },\n      password: {\n        label: 'Password',\n        type: 'password'\n      }\n    },\n\n    async authorize(credentials) {\n      // You might want to pull this call out so we're not making a new LDAP client on every login attemp\n      const client = ldap.createClient({\n        url: process.env.LDAP_URI\n      }); // Essentially promisify the LDAPJS client.bind function\n\n      return new Promise((resolve, reject) => {\n        client.bind(credentials.username, credentials.password, error => {\n          if (error) {\n            console.error('Failed');\n            reject();\n          } else {\n            console.log('Logged in');\n            resolve({\n              username: credentials.username,\n              password: credentials.password\n            });\n          }\n        });\n      });\n    }\n\n  })],\n  callbacks: {\n    async jwt(token, user, account, profile, isNewUser) {\n      const isSignIn = !!user;\n\n      if (isSignIn) {\n        token.username = user.username;\n        token.password = user.password;\n      }\n\n      return token;\n    },\n\n    async session(session, user) {\n      return _objectSpread(_objectSpread({}, session), {}, {\n        user: {\n          username: user.username\n        }\n      });\n    }\n\n  },\n  secret: process.env.NEXTAUTH_SECRET,\n  jwt: {\n    secret: process.env.NEXTAUTH_SECRET,\n    encryption: true // Very important to encrypt the JWT, otherwise you're leaking username+password into the browser\n\n  }\n});","map":{"version":3,"sources":["E:/src/next/sistemas/idpb-app/src/pages/api/auth/[...nextauth].js"],"names":["NextAuth","Providers","ldap","providers","Credentials","name","credentials","username","label","type","placeholder","password","authorize","client","createClient","url","process","env","LDAP_URI","Promise","resolve","reject","bind","error","console","log","callbacks","jwt","token","user","account","profile","isNewUser","isSignIn","session","secret","NEXTAUTH_SECRET","encryption"],"mappings":";;;;;;AAAA,OAAOA,QAAP,MAAqB,WAArB;AACA,OAAOC,SAAP,MAAsB,qBAAtB;AACA,OAAOC,IAAP,MAAiB,QAAjB,C,CACA;;AAEA,eAAeF,QAAQ,CAAC;AACtBG,EAAAA,SAAS,EAAE,CACTF,SAAS,CAACG,WAAV,CAAsB;AACpBC,IAAAA,IAAI,EAAE,MADc;AAEpBC,IAAAA,WAAW,EAAE;AACXC,MAAAA,QAAQ,EAAE;AAAEC,QAAAA,KAAK,EAAE,IAAT;AAAeC,QAAAA,IAAI,EAAE,MAArB;AAA6BC,QAAAA,WAAW,EAAE;AAA1C,OADC;AAEXC,MAAAA,QAAQ,EAAE;AAAEH,QAAAA,KAAK,EAAE,UAAT;AAAqBC,QAAAA,IAAI,EAAE;AAA3B;AAFC,KAFO;;AAMpB,UAAMG,SAAN,CAAgBN,WAAhB,EAA6B;AAC3B;AACA,YAAMO,MAAM,GAAGX,IAAI,CAACY,YAAL,CAAkB;AAC/BC,QAAAA,GAAG,EAAEC,OAAO,CAACC,GAAR,CAAYC;AADc,OAAlB,CAAf,CAF2B,CAM3B;;AACA,aAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtCR,QAAAA,MAAM,CAACS,IAAP,CAAYhB,WAAW,CAACC,QAAxB,EAAkCD,WAAW,CAACK,QAA9C,EAAyDY,KAAD,IAAW;AACjE,cAAIA,KAAJ,EAAW;AACTC,YAAAA,OAAO,CAACD,KAAR,CAAc,QAAd;AACAF,YAAAA,MAAM;AACP,WAHD,MAGO;AACLG,YAAAA,OAAO,CAACC,GAAR,CAAY,WAAZ;AACAL,YAAAA,OAAO,CAAC;AACNb,cAAAA,QAAQ,EAAED,WAAW,CAACC,QADhB;AAENI,cAAAA,QAAQ,EAAEL,WAAW,CAACK;AAFhB,aAAD,CAAP;AAID;AACF,SAXD;AAYD,OAbM,CAAP;AAcD;;AA3BmB,GAAtB,CADS,CADW;AAgCtBe,EAAAA,SAAS,EAAE;AACT,UAAMC,GAAN,CAAUC,KAAV,EAAiBC,IAAjB,EAAuBC,OAAvB,EAAgCC,OAAhC,EAAyCC,SAAzC,EAAoD;AAClD,YAAMC,QAAQ,GAAG,CAAC,CAACJ,IAAnB;;AACA,UAAII,QAAJ,EAAc;AACZL,QAAAA,KAAK,CAACrB,QAAN,GAAiBsB,IAAI,CAACtB,QAAtB;AACAqB,QAAAA,KAAK,CAACjB,QAAN,GAAiBkB,IAAI,CAAClB,QAAtB;AACD;;AACD,aAAOiB,KAAP;AACD,KARQ;;AAST,UAAMM,OAAN,CAAcA,OAAd,EAAuBL,IAAvB,EAA6B;AAC3B,6CAAYK,OAAZ;AAAqBL,QAAAA,IAAI,EAAE;AAAEtB,UAAAA,QAAQ,EAAEsB,IAAI,CAACtB;AAAjB;AAA3B;AACD;;AAXQ,GAhCW;AA6CtB4B,EAAAA,MAAM,EAAEnB,OAAO,CAACC,GAAR,CAAYmB,eA7CE;AA8CtBT,EAAAA,GAAG,EAAE;AACHQ,IAAAA,MAAM,EAAEnB,OAAO,CAACC,GAAR,CAAYmB,eADjB;AAEHC,IAAAA,UAAU,EAAE,IAFT,CAEe;;AAFf;AA9CiB,CAAD,CAAvB","sourcesContent":["import NextAuth from 'next-auth';\r\nimport Providers from 'next-auth/providers';\r\nimport ldap from 'ldapjs';\r\n// const ldap = require('ldapjs');\r\n\r\nexport default NextAuth({\r\n  providers: [\r\n    Providers.Credentials({\r\n      name: 'LDAP',\r\n      credentials: {\r\n        username: { label: 'DN', type: 'text', placeholder: '' },\r\n        password: { label: 'Password', type: 'password' },\r\n      },\r\n      async authorize(credentials) {\r\n        // You might want to pull this call out so we're not making a new LDAP client on every login attemp\r\n        const client = ldap.createClient({\r\n          url: process.env.LDAP_URI,\r\n        });\r\n\r\n        // Essentially promisify the LDAPJS client.bind function\r\n        return new Promise((resolve, reject) => {\r\n          client.bind(credentials.username, credentials.password, (error) => {\r\n            if (error) {\r\n              console.error('Failed');\r\n              reject();\r\n            } else {\r\n              console.log('Logged in');\r\n              resolve({\r\n                username: credentials.username,\r\n                password: credentials.password,\r\n              });\r\n            }\r\n          });\r\n        });\r\n      },\r\n    }),\r\n  ],\r\n  callbacks: {\r\n    async jwt(token, user, account, profile, isNewUser) {\r\n      const isSignIn = !!user;\r\n      if (isSignIn) {\r\n        token.username = user.username;\r\n        token.password = user.password;\r\n      }\r\n      return token;\r\n    },\r\n    async session(session, user) {\r\n      return { ...session, user: { username: user.username } };\r\n    },\r\n  },\r\n  secret: process.env.NEXTAUTH_SECRET,\r\n  jwt: {\r\n    secret: process.env.NEXTAUTH_SECRET,\r\n    encryption: true, // Very important to encrypt the JWT, otherwise you're leaking username+password into the browser\r\n  },\r\n});\r\n"]},"metadata":{},"sourceType":"module"}